

# 一、多线程概念

## 1.进程与线程之间的关系

一个很经典的面试题。

进程：是一个程序的运行实体，也可以说是一个正在运行中的程序，是系统分配资源的最小单位，进程之间资源是独立的。而一个进程可以创建出多个线程。

线程：是cup调度的一个最小单元，进程可以创建多个线程来同时执行多个任务，线程之间共享进程的资源。

## 2.为什么使用多线程

使用多线程可以充分利用cpu资源尤其是多核cpu，能够提升程序的运行速度、提升用户的体验度、比如一个软件可以一边更新程序，一边使用这就是用多线程完成的。

## 3.使用的线程越多程序越快吗？

不一定，因为线程的使用有一些限制，如上下文切换、线程的创建都需要消耗资源所以使用线程要适量，在某些场合下多线程不一定比单线程快，比如执行的任务消耗的资源很小，小到比创建线程或上下文切换要消耗的资源还要少，这种使用使用多线程反倒会降低程序性能。还有就是硬件资源限制和软件资源限制，比如硬件方面磁盘IO的吞吐量是有限的你开再多的线程也没用反而额外增添了程序负担，软件资源限制比如socket连接数数据库连接数等限制。

## 4.多线程遇到的问题

* 安全性
* 活跃性：死锁(互相都需要对方持有的资源，但互相都不释放)，活锁(互相谦让资源，结果大家都没有用到资源)，饥饿(线程得不到执行，有可能优先级问题有可能一直被阻塞)
* 性能

  # 二、多线程基础 

## 1.线程状态

1. 初始化
2. 就绪
3. 运行
4. 阻塞(blocking)
5. 等待(wait)
6. 等待超时
7. 终止 

## 2.线程创建

1.继承Thread类，使用覆盖run方法方式执行

2.实现Runnable接口，在Thread有参构造中传递进去并复制给target属性，在执行run时判断target是否存在，存在则执行target的run()。

3.实现Callable接口，实现call()，然后使用FutureTask构造函数包装callable实现类，此类是runnable的实现所以可以传递给Thread的有参构造。call()执行后会有返回值

4.使用线程池，使用Executors创建线程池，使用线程池的execute()方法提交任务并执行

5.使用定时器

```java
		Timer a =new Timer();
		//第一个参数就是一个runnable实现，但不是直接实现类
		a.schedule(new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
			}
		}, 0,10);
```

6.Spring实现多线程

```java
@SpringBootApplication
@MapperScan(basePackages="com.zchg.dao")
@EnableAsync	//启动异步支持
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
	
}

//在需要异步执行的方法加注解
@Async
public void a() {
    while(true)
		System.out.println("a");
}
@Async
public void b() {
     while(true) 
         System.out.println("b");
}
调用这两个方法的结果是两个方法来同步死循环运行，正常非多线程的情况下是只能有一个方法在一直死循环
```

7.lambda表达式的并行流。

## 3.Thread API

### 3.1中断线程

* interrupt()：设置中断标记为true，默认为false
* interrupted()：查看当前中断标记，并重置中断标记为false
* isInterrupted()：查看当前中断标记，不重置中断标记

中断线程示例：

```java
public static void main(String[] args) throws InterruptedException {
		Thread t1 = new Thread(()->{
            //不是中断的话一直执行
			while(!Thread.currentThread().interrupted()) {
				System.out.println("线程正在执行：");
			}
		});
		
		t1.start();
		Thread.currentThread().sleep(1000);
		t1.interrupt();		
}
```

## 5.线程间通信

### 5.1 wait/notify

特点：在wait等待时会释放锁，对wait notify的调用顺序有要求，如果先调用notify后调用wait的话线程会一直挂起

### 5.2 park/unPark

特点：调用park()等待时不会释放锁，所以在同步块中使用时需要注意死锁问题，对调用顺序没有要求，先调用unPark() 后调用park()时不会进入等待状态，但是unPark()不会叠加。

```java
//在这种情况下会产生死锁。
synchronized (this) {
    LockSupport.park();
}
synchronized (this) {
    LockSupport.unpark(Thread);
}
```

### 5.3 伪唤醒

我们在判断线程是否进入等待状态时，官方建议使用while而不是if，因为有CPU底层的原因可能会产生为唤醒，也就是说线程在被唤醒的时候可能并不是因为我们调用notify或者unpark唤醒的而是因为底层的CPU问题被自动唤醒了，这个时候我们的被唤醒的条件可能还没有达到需要再唤醒后再判断一下是否满足唤醒条件，这个时候使用while比if合适。

# 三、synchronized使用与实现

synchronized叫内置锁或隐式锁、监视器锁，他的基本使用方式有一下三种：

* 修饰在普通方法上，使用当前this实例作为锁
* 修饰在静态方法上，使用当前类的class对象作为锁
* 修饰在代码块上，使用给定的对象作为锁

## 1.字节码的实现

编译器会在synchronized修饰的代码块的第一行插入一条moniterenter指令，在末尾插入一条moniterexit指令，由这两个指令来保证代码块的同步。可以使用javap查看到这两个指令。

## 2.锁的存储

java中每个对象都可以作为锁，锁是存储在对象头当中的，对像头有一个markword字段，其中存储了锁信息。

markword主要包含：线程ID，是否是偏向锁标志，锁标志。锁表标志分别代表锁的几种状态，不同状态下的锁markword存储的信息也不同。

## 3.锁状态与锁升级

内置锁总共有四种状态：无锁，偏向锁，轻量级锁，重量级锁。在线程竞争锁的过程中会发生锁状态的升级，锁的状态只能升级不能降级。

升级过程如下：

1. 无锁状态：当线程是第一个获取到这个锁的时候，会把锁信息改为偏向锁并把线程ID改为自己的ID，此时锁就升级为了偏向锁。
2. 偏向锁：当一个线程已经持有了偏向锁，这个时候当其他线程来获取锁时会先检测锁信息中线程ID是否是自己，如果不是，则查看偏向锁标志，如果是偏向锁，则会查看线程是否存活，如果不存活则CAS尝试把线程ID改为自己此时还是偏向锁，如果线程还存活着证明线程间存在竞争则会把拥有偏向锁的线程停止，把锁状态改为轻量级锁并把markword复制到当前持有锁的线程的栈帧中并把对像头的markword改为指向栈帧的指针，然后继续执行拥有锁的线程执行完后释放锁并把栈中的markword替换会对像头。
3. 轻量级锁：当一个线程已经持有了轻量级锁而另一个线程没有获取到，则会采用CAS自旋来不断尝试着去获取锁，如果尝试的次数过多将会自旋失败，则会把轻量级锁升级为重量级锁，并把markword中指向轻量级锁的指针改为重量级的，并进入到阻塞状态，这是当持有锁的线程执行完代码后会进行CAS把markword替换会对像头中，但此时对像头中的markword已经被改了所以失败，则会释放锁并唤醒等待线程。

几种锁状态的比较：

偏向锁：适合在只有一个线程访问同步代码块的时候，或者线程竞争不激烈的时候。                                                     

轻量级锁：在同步代码块执行非常快的时候，因为自旋也消耗CPU资源，如果自旋执行时间比较长会比阻塞更消耗		资源。

重量级锁：在同步代码块执行慢的时候使用。

## 4.锁优化

1. 锁粗化：当频繁获取释放锁的时候也是消耗资源的，如果在两次获取锁中间执行的代码消耗很小的情况下(小到比获取锁释放锁消耗还小)时可以考虑吧中间执行的代码也放入同步代码块中，减少锁的获取释放次数，如下示例：

   ```JAVA
   public static void main(String[] args) {
   		synchronized(lock) {
   			//操作1
   		}
   		//操作2，很会快执行结束
   		synchronized(lock) {
   			//操作3
   		}
   }
   //这种情况下jvm会优化为，把锁的范围扩大了
   public static void main(String[] args) {
   		synchronized(lock) {
   			//操作1
                //操作2，很会快执行结束
                //操作3
   		}
   }
   ```

2. 锁消除：在某些情况下，不需要进行加锁操作时(不存在线程安全问题)jvm会把这个不必要的锁取消掉，如下示例：

   ```java
   public class Other {
   	
   	public static void main(String[] args) {
           //当两个线程分别使用两个util对象进行操作时就不会存在线程安全问题，因为使用的不是一个锁
           //在这种情况下jvm会把锁消除掉
   		new Thread(()->{
   			Util util = new Util();
   			util.print();
   		}).start();
   		
   		new Thread(()->{
   			Util util = new Util();
   			util.print();
   		}).start();
   	}
   	
   	static class Util {
   		public synchronized void print() {
   			//有一些对共享资源的读写操作
   		}
   	}
   
   }
   ```

   > jvm必须是以server模式运行时才会进行锁消除，同时必须开启逃逸分析: 
   >
   > -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks 
   >
   > 其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。 

   > 32位虚拟机默认为client模式运行，64位虚拟机默认为server模式运行，可以使用java -version查看

3. 可重入锁：锁内部会有一个计数器，进入锁持有次数，让线程持有一次这个锁时会把计数器加一，释放锁时减一，当重复持有锁时进行累加。可重入锁可以避免死锁，示例如下：

   ```java
       public synchronized void a() {
           //如果锁不能冲入的话这里会发生死锁，因为b()需要等待a()执行完释放锁才能进入，而a()还需要等b	         //执行完才能释放。
   		b();
   	}
   	public synchronized void b() {	
   	}
   ```


## 4.synchronized内存语义

happens-before原则中规定：锁的释放happens-before锁的获取，也就是说锁获取时一定对上一个线程锁释放之前操作的结果可见。

内存语义的实现：当一个线程释放锁时会把本地内存中数据刷新到主存，当一个线程获取锁时才会把本地内存中的数据废弃，然后去主存中获取值。

下面是一个synchronized内存语义的例子：

```java
/***
 * synchronized内存语义，根据锁的happens-before规则我们知道，释放锁happens-before获取锁，
 * 也就意味这，获取锁对释放锁之前的结果可见，在这个示例中显然没有满足这个条件所以n还是不可见的。
 * 锁的内存语义总结一句话就是：当一个线程释放了锁会把本地内存内容刷新到主内存，
 * 当一个线程去获取锁时才会把本地内存作废并去主存取数据。
 * @author Administrator
 *
 */
public class Other {
	
	private static int n = 0; 
	
	public synchronized void add() {
		n++;
	}
	//这个问题使用锁的内存语义解决方式就是在读取n时获取锁，这样就满足了内存语义就会去主存读取新的n值
	/*public synchronized int get() {
		return n;
	}*/
	public static void main(String[] args) {
	    Other o = new Other();
		new Thread(()->{
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			for(int i=0;i<200;i++) {
				o.add();
			}	
		}).start();
		
		/*while(o.get()<100) {
			
		}*/
		
        while(n<100){
            
        }
        
		System.out.println("执行完毕！");
	}	
}
```

# 四、volatile使用与实现

## 1.volatile使用

volatile关键字保证了多线程之间的内存可见性，第二个作用是禁止指令重排序，在线程安全的单例模式（双重检查锁定）中使用，在没有使用volatile修饰共享变量时一个线程对共享变量修改时，其它线程读取不到这个共享变量修改后的最新值，这也就是内存可见性问题，如下示例：

~~~java
public class B{
    //static volatile boolean flag = false;
    //当共享变量flag不是volatile修饰时，下面代码会进入死循环中，第一个线程读取不到flag修改后的值
    static boolean flag = false;
	public static void main(String[] args) {
		new Thread(()-> {
			while(true) {
				if(flag) {
					System.out.println("T1");
					break;
				}
			}
		}).start();
		
		new Thread(()->{
			try {
				Thread.sleep(300);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			flag = true;
			System.out.println(flag);
		}).start();
	}
}

~~~

> volatile还保证了被修饰的变量不会被重排序，使用插入内存屏障指令的方式对特定类型的编译器、处理器做禁止重排序。

## 2.底层实现

当我们把带volatile修饰的哪行代码转换为汇编指令时会发现，会多出一条lock#指令，而lock#指令会做两件事：

* 把当前修改的缓存行中的数据回写到内存中。
* 会把其他cpu core缓存中指向相同数据的缓存行废弃，使用数据时会直接去内存获取数据。

这个是基于MESI(缓存一致性协议)来保证的内存可见性。

操作系统层实现：我们多核cpu，每个cpu下都有对应的高速缓存，cpu去读取数据时首先会到告诉缓存查询，没命中就会去内存取并把数据存入到高级缓存中，这个机制引发了数据不一致的问题，一个cpu更改了高速缓存中的数据但没写入到主存，而其他cpu取读取数据时也不会读取到这个最新的数据产生了不一致问题，后来高速缓存中定义了这样的规则，只要高速缓存中的数据发生改变了，就需要把数据回写到主存，并通知其他cpu下的高速缓存无效，这样保证了数据一致性

## 3.使用场景

在读多写少的情况下适合使用volatile，因为volatile只保证了内存的可见性，而并没有像锁一样保证了复合操作的原子性，所以当并发写操作时还是线程不安全的，但当其他线程读操作只有一个线程进行写操作时使用volatile要比使用锁要合适一些。

> 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。 CAS保证原子性volatile保证可见性。

## 4.volatile内存语义

根据`JMM`中`happens-before`原则中的规定，一个volatile变量的写happens-before读，也就是读操作对之前写操作的结果可见。

内存语义的实现：当对一个volatile变量写操作时会把该线程本地内存数据刷新到主存中，当一个volatile变量读操作时会把该线程本地内存作废去主存中查询数据。

# 五、AQS

AQS(AbstractQueuedSynchronizer)是juc包下大部分同步组件的实现基础，在了解他的使用时通常通过阅读`ReentrantLock`类的源码实现来掌握AQS的用法，而想要更容易看懂`ReentrantLock`类的源码就需要了解锁实现的一些基本思路，所以要先能够自己写一个简易的锁来理解锁实现的思路。下面是一个实现锁的示例：

```java
/***
 * 这个类实现了一个简易的可重入锁，共维护了两个共享状态.
 * state为锁的持有状态,为0时表示未被持有，大于0时表示已被持有
 * cur为持有锁的线程
 */
public class MyLock {
	private int state = 0;
	private Thread cur;
	
	public synchronized void lock() {
		//当有线程获取锁时则判读是否已被其他线程持有，如果有则等待
		while(state != 0 && cur != Thread.currentThread()) {
			try {
				wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		//获取锁时维护锁状态
		state++;
		cur = Thread.currentThread();
	}
	
	public synchronized void unlock() {
		if(cur == Thread.currentThread()) {
			//释放锁时维护锁状态，如果锁状态为0时则彻底释放锁并唤醒其他等待线程
			state--;
			if(state == 0) {
				cur = null;
				notifyAll();
			}
		}
	}
}
```

## 1. AQS源码架构

AQS中主要维护了两个东西，一个用双向链表实现的CLH队列和一个描述锁状态的int属性state。

CLH队列：在锁中用来存储被阻塞的线程，头节点是正持有锁的线程，头结点以后是需要被唤醒的阻塞线程。

state属性：用来表示锁的状态，初始值为0表示未被任何线程持有，大于0时表示被持有，锁每重入一次state+1。

AQS使用了模板设计模式，是为我们提供的同步器的模板，我们可以实现AQS中的模板方法来实现自己的同步器，为我们提供的模板方法主要以下下有五个：

* tryAcquire() ：独占式获取资源
* tryAcquireShared()：共享式获取
* tryRelease()：独占式释放
* tryReleaseShared()：共享式释放
* isHeldExclusively()：资源是否被锁定

我们只需要实现独占式或共享式中一种模式的方法就可以

## 2.基于AQS实现的锁

```java
/***
 * 基于AQS实现的重入锁,主要实现tryAcquire(),tryRelease()用来定义获取释放资源的逻辑
 */
public class MyLock implements Lock{
	
	private Syn syn;
	
    public MyLock() {
		syn = new Syn();
	}
	
	@Override
	public void lock() {
		syn.acquire();
	}
	
	@Override
	public void unlock() {
		//调用AQS的release()，release()中则会调用我们实现的tryRelease()
		syn.release(1);
	}
	//创建一个内部同步器继承AQS
	private class Syn extends AbstractQueuedSynchronizer{
		//返回false表示获取锁失败，AQS则会把失败的线程加入到CLH队列中
		@Override protected boolean tryAcquire(int arg) {
			Thread cur = Thread.currentThread();
			int state = getState();
			//如果state为0表示锁未被任何线程持有，则用CAS获取锁成功返回true
			if(state == 0 && compareAndSetState(0, arg)) {
				setExclusiveOwnerThread(cur);
				return true;
			}
			//如果是要重入锁的则把锁状态累加并返回true
			if(cur == getExclusiveOwnerThread()
					&& compareAndSetState(state, state+arg)) {
				return true;
			}
			//如果获取锁失败则返回false
			return false;
		}
		
		//返回true表示释放锁成功，AQS则会把已释放锁的线程移出CLH队列，并把下一个等待的线程唤醒并设置为队列头元素
		@Override protected boolean tryRelease(int arg) {
			Thread cur = Thread.currentThread();
			int state = getState();
			//如果当前线程是持有锁的线程
			if(cur == getExclusiveOwnerThread()) {
				int newState = state-arg;
				setState(newState);
				//释放后锁状态为0时表示锁已全部释放
				if(newState == 0) {
					setExclusiveOwnerThread(null);
					return true;
				}
			}
			return false;
		}
	}
}
```

# 六、JUC下的各种锁

lockSupport：是java线程阻塞原语，其中park()设置标记为0阻塞线程，unpark()设置标记为1恢复线程。跟wait()与notify()类似。

## 1.ReentrantLock

它是可重入锁，它内部基于AQS实现了两个自己的同步器，分别是`FairSync`公平模式 和`NonfairSync`非公平模式。

### 1.1实例的创建

创建非公平锁

```java
public ReentrantLock() {
        sync = new NonfairSync();
}
```

创建公平锁

```java
public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
}
```

### 1.2锁获取

非公平模式获取锁

```java
//1.这是NonfairSync下的方法，首先会执行到这个方法
final void lock() {
    		//使用CAS修改锁状态，修改成功证明获取锁
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);//没有获取锁执行AQS的acquire()
}

//2.然后执行到这个方法
 final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            //如果锁还未被线程获取则用CAS获取
     	    if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }//如果锁已被线程获取则判断是否是重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }//如果既没获取到锁也不是锁重入则返回false证明锁获取失败
            return false;
  }
 //3.AQS中根据锁获取情况进行维护CLH队列
 public final void acquire(int arg) {
        if (!tryAcquire(arg) && 
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))//如果没获取到锁则加入等待队列并阻塞线程
            selfInterrupt();
 }
```

公平模式获取锁

```java
//执行FairSync下的方法
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //公平锁与非公平锁的实现关键点就是hasQueuedPredecessors(),用他来实现公平
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
}
//这个方法用来判断，当前线程是否是CLH队列中排在第一个的等待线程，如果是第一个等待线程返回false
//只有这个方法返回false时才会让其获取锁，这就完成了排队的效果也就达成了公平性质
public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

释放锁跟上面基本一致的流程。

## 2.ReentrantReadWriteLock

是一个读写锁，其中有读锁和写锁两把锁

### 2.1 基本使用

```java
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
Lock readLock = readWriteLock.readLock();
Lock writeLock = readWriteLock.writeLock();
//在读操作时用读锁，在写操作时用写锁
```

### 2.2 实现原理

这里由于有两把锁其中还有一个是共享锁，所以记录锁重入次数的标记state有些变化，记录标记使用如下方式：

他把int 32位的值分为高16位与低16位，其中高位用来记录共享锁(读锁)的重入次数，地位记录独占锁(读锁)的重入次数，下面是源码：

```jaVA
 static final int SHARED_SHIFT   = 16;	//位移的位数
//高位累加的单位，每次重入加SHARED_UNIT
 static final int SHARED_UNIT    = (1 << SHARED_SHIFT); 	
 static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1; //最大重入次数
 static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1; //低16位的掩码，低16位全为1

 //获取高16位的有效数，使用带符号位右移把高16位移到了低16位的位置，原先的高16位都补0
 static int sharedCount(int c)    { return c >>> SHARED_SHIFT; } 
 //获取低16位的有效数，采用掩码安位与操作
 static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; } 
```



取锁的思路：

1. 当获取**读锁**时：

   （1）判断当前写锁是否被持有，持有则获取失败进入等待队列，否则向下执行

   （2）判断读锁是否应该阻塞，如果不阻塞，则尝试获取锁，

   （3）执行fullTryAcquireShared()有三种情况，读锁应该阻塞，读锁数量大于上限，CAS获取锁失败，这个方法用来重复获取锁，在获取锁之前要判断，读锁是否被其他线程获取，或者如果读锁线程应该阻塞时只要读锁还没有被获取到那就获取锁失败

   ```java
   	protected final int tryAcquireShared(int unused) {
          
               Thread current = Thread.currentThread();
               int c = getState();
               //读锁是否已获取，如果获取则夺锁失败
               if (exclusiveCount(c) != 0 &&
                   getExclusiveOwnerThread() != current)
                   return -1;
               // 获取共享锁的持有次数
               int r = sharedCount(c);
               //如果下一个等待唤醒的线程是读线程则夺锁失败
               if (!readerShouldBlock() &&
                   r < MAX_COUNT &&
                   //修改读锁的计数加一个单位，也就相当于加1，最后获取锁成功
                   compareAndSetState(c, c + SHARED_UNIT)) {
                   if (r == 0) {
                       firstReader = current;
                       firstReaderHoldCount = 1;
                   } else if (firstReader == current) {
                       firstReaderHoldCount++;
                   } else {
                       HoldCounter rh = cachedHoldCounter;
                       //如果是其他线程获取读锁的话为这个线程创建一个本地变量单独统计他的锁重入数
                       if (rh == null || rh.tid != getThreadId(current))
                           cachedHoldCounter = rh = readHolds.get();
                       else if (rh.count == 0)
                           readHolds.set(rh);
                       rh.count++;
                   }
                   return 1;
               }
               return fullTryAcquireShared(current);
           }
   ```

   

2. 获取写锁时：

   （1）判断是否是锁重入，不是的话则获取失败

   （2）CAS尝试获取锁

   ```java
   protected final boolean tryAcquire(int acquires) {
               Thread current = Thread.currentThread();
               int c = getState();
               int w = exclusiveCount(c);
               //如果锁已被持有则判断是否是锁重入
               if (c != 0) {
                   // (Note: if c != 0 and w == 0 then shared count != 0)
                   if (w == 0 || current != getExclusiveOwnerThread())
                       return false;
                   if (w + exclusiveCount(acquires) > MAX_COUNT)
                       throw new Error("Maximum lock count exceeded");
                   // Reentrant acquire
                   setState(c + acquires);
                   return true;
               }
       	    //CAS获取锁
               if (writerShouldBlock() ||
                   !compareAndSetState(c, c + acquires))
                   return false;
               setExclusiveOwnerThread(current);
               return true;
           }
   ```

   

### 2.3 锁降级

锁降级就是在写锁释放之前，获取读锁，这样写锁就回降级为读锁，所以不会发生死锁

```java
//使用锁降级的愿意是，当多线程竞争写锁时，写锁释放后有肯能还会被下一个写线程获取到写锁执行写操作
//这时等两次写操作后读线程在获取到锁之后得到得值就是两次写后的值，而不是当前线程一次写后的值了
public class Cur {
    public static void main(String[] args){
        ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
        Lock readLock = readWriteLock.readLock();
        Lock writeLock = readWriteLock.writeLock();

        writeLock.lock();
        //对共享数据写操作完成后
        .......
        readLock.lock();
        //这时写锁降级为读锁并释放
        writeLock.unlock();
        readLock.unlock();
    }
}
//源码上实现锁降级的关键点就是判断当前再次获取锁的时候是判断当前线程是否是持有锁的线程
//当写锁被占用时，并此线程不是当前持有锁线程才失败
 if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)
                return -1;
```

### 2.4 公平与非公平实现

公平锁：还是跟以前一样，保证获取锁的显示是排队在最前面的。

非公平锁：只要能保证读写分离就可以获取到锁，哪怕排队在最前面的线程是读操作，但当前持有锁的线程是读操作，这样后来的获取读锁的线程可以直接持有锁而不需要排队等待，就相当于插队了。这样就引发了一个问题当读操作过多时会导致写线程的饥饿，在jdk1.8引入了一个新的锁`StampedLock`来解决这个问题。

## 3.StampedLock

这是对读写锁的升级，这个锁总共有以下三种模式：

* 读模式：也就是一把共享锁
* 写模式：一把独占锁
* 乐观读模式：无锁编程的方式

这三种模式可以互相转换，正因为模式不确定所以这个类没有直接实现Lock接口与ReadWriteLock接口，这个类的乐观模式很脆弱，在乐观读过程中任何写操作都会让其操作失败，所以适合在读代码段很短时使用，另外这个锁不是一个重入锁。在使用上这个锁与其他的不同点是 获取锁时得到得是一个戳值而不是`Lock`对象，这个戳值就代表着锁的状态。而StampedLock则提供了一种乐观的读策略,这种乐观策略的锁非常类似于无锁的操作,使得乐观锁完全不会阻塞写线程 .

下面是常用的API

| name                 | department                                                   |
| -------------------- | ------------------------------------------------------------ |
| writeLock()          | 获取写锁模式                                                 |
| unlockWrite(stamp)   | 释放写锁                                                     |
| tryOptimisticRead()  | 获取乐观读模式的戳值，他没有锁所以不用释放                   |
| validate(stamp)      | 验证乐观锁操作过程中是否有写操作发生，成功返回true表示没有写 |
| readLock()           | 获取读锁                                                     |
| unlockRead(stamp)    | 释放读锁                                                     |
| tryConvertTo*(stamp) | 进行转换锁状态，*代表三种状态的名字，戳值代表已有的锁状态    |
| is*(stamp)           | 用来判断是否是某重状态的锁                                   |
| unlock(stamp)        | 可以释放任何类型的锁                                         |

下面是使用示例：

```java
 class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();

   // 一个独占锁的使用
   void move(double deltaX, double deltaY) {
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }

   // 一个只读方法
   // 乐观读升级为读锁模式
   double distanceFromOrigin() {
     long stamp = sl.tryOptimisticRead();
     try {
       retryHoldingLock: for (;; stamp = sl.readLock()) {
         if (stamp == 0L)
           continue retryHoldingLock;
         // possibly racy reads
         double currentX = x;
         double currentY = y;
         if (!sl.validate(stamp))
           continue retryHoldingLock;
         return Math.hypot(currentX, currentY);
       }
     } finally {
       if (StampedLock.isReadLockStamp(stamp))
         sl.unlockRead(stamp);
     }
   }

   // 乐观读升级到写锁模式
   void moveIfAtOrigin(double newX, double newY) {
     long stamp = sl.tryOptimisticRead();
     try {
       retryHoldingLock: for (;; stamp = sl.writeLock()) {
         if (stamp == 0L)
           continue retryHoldingLock;
         // possibly racy reads
         double currentX = x;
         double currentY = y;
         if (!sl.validate(stamp))
           continue retryHoldingLock;
         if (currentX != 0.0 || currentY != 0.0)
           break;
         stamp = sl.tryConvertToWriteLock(stamp);
         if (stamp == 0L)
           continue retryHoldingLock;
         // exclusive access
         x = newX;
         y = newY;
         return;
       }
     } finally {
       if (StampedLock.isWriteLockStamp(stamp))
         sl.unlockWrite(stamp);
     }
   }

   // 把读锁升级到写锁
   void moveIfAtOrigin(double newX, double newY) {
     long stamp = sl.readLock();
     try {
       while (x == 0.0 && y == 0.0) {
         long ws = sl.tryConvertToWriteLock(stamp);
         if (ws != 0L) {
           stamp = ws;
           x = newX;
           y = newY;
           break;
         }
         else {
           sl.unlockRead(stamp);
           stamp = sl.writeLock();
         }
       }
     } finally {
       sl.unlock(stamp);
     }
   }
 }
```

## 4.Condition

### 1.基本使用

condition用于线程之间的调度类似notify与wait，正常情况下我们要完成1,2,3线程交替执行可以使用wait与notify来完成，但是notify唤醒线程是随机的没办法指定唤醒哪个线程，使用Condition可以完成这个功能。

下面是用wait与notify完成的线程交替打印

```java
//根据state值判断该线程是否被唤醒
public class OrderExec {
    private static int state = 1;
    
    public static void main(String[] args){
        condition();
    }

    public static int getState(){
        return state;
    }

    public static void setState(int state){
        OrderExec.state = state;
    }

    public static void WaitNotify(){
        Thread t1 = new Thread(new Thread1());
        Thread t2 = new Thread(new Thread2());
        Thread t3 = new Thread(new Thread3());
        t1.start();t2.start();t3.start();
    }
}

class Thread1 implements Runnable {

    @Override
    public void run() {
        synchronized (OrderExec.class){
            while(true) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (OrderExec.getState() == 1) {
                    System.out.println("线程1执行");
                    OrderExec.setState(2);
                    OrderExec.class.notifyAll();
                } else {
                    try {
                        OrderExec.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}

class Thread2 implements Runnable {

    @Override
    public void run() {
        synchronized (OrderExec.class){
            while (true){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(OrderExec.getState() == 2){
                    System.out.println("线程2执行");
                    OrderExec.setState(3);
                    OrderExec.class.notifyAll();
                }else{
                    try {
                        OrderExec.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}

class Thread3 implements Runnable {

    @Override
    public void run() {
        synchronized (OrderExec.class){
            while(true){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if(OrderExec.getState() == 3){
                    System.out.println("线程3执行");
                    OrderExec.setState(1);
                    OrderExec.class.notifyAll();
                }else{
                    try {
                        OrderExec.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

使用Condition来控制线程交替执行

```java
//一开始三个线程都是等待的，等三个线程都等待后再把第一个唤醒，第一个完成后会唤醒第二的依次类推
public class OrderExec {
    public static Lock lock = new ReentrantLock();
    public static Condition c1 = lock.newCondition();
    public static Condition c2 = lock.newCondition();
    public static Condition c3 = lock.newCondition();

    public static void main(String[] args){
        condition();
    }

    public static void condition(){
        Thread t1 = new Thread(new Cod1());
        Thread t2 = new Thread(new Cod2());
        Thread t3 = new Thread(new Cod3());
        t1.start();t2.start();t3.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        lock.lock();
        c1.signal();
        lock.unlock();
    }

}

class Cod1 implements Runnable {

    @Override
    public void run() {
        while (true){
            OrderExec.lock.lock();
            try {
                Thread.sleep(500);
                OrderExec.c1.await();
                System.out.println("线程1执行");
                OrderExec.c2.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                OrderExec.lock.unlock();
            }
        }
    }
}

class Cod2 implements Runnable {

    @Override
    public void run() {
        while (true){
            OrderExec.lock.lock();
            try {
                Thread.sleep(500);
                OrderExec.c2.await();
                System.out.println("线程2执行");
                OrderExec.c3.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                OrderExec.lock.unlock();
            }
        }
    }
}

class Cod3 implements Runnable {

    @Override
    public void run() {
        while (true){
            OrderExec.lock.lock();
            try {
                Thread.sleep(500);
                OrderExec.c3.await();
                System.out.println("线程3执行");
                OrderExec.c1.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                OrderExec.lock.unlock();
            }
        }
    }
}
```

### 2.源码分析

每个ConditionI对像都维护着一个等待队列，把等待的线程加入到等待队列中，而多个Condition对象又关联着同一把锁，所以多个Condition对象把唤醒的线程又加入到了同步队列中，因此我们可以把不同的线程使用不同的Condition对象加入到不同的等待队列中，所以才会可以执行对某一个等待队列中的线程唤醒

```java
      public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //把线程添加到等待队列中
            Node node = addConditionWaiter();
            //释放当前线程持有的锁资源
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //如果不在同步队列中则等待
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }

        public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            //获取第一个等待唤醒的线程
            Node first = firstWaiter;
            //如果不为空则唤醒
            if (first != null)
                doSignal(first);
        }
```



# 七、生产者消费者模型

## 1.使用wait与notify实现

```java
//仓库生产者向其中添加，消费者冲仓库中取
public class Repostory {
    private Queue<Integer> queue = new LinkedList<>();
    private int capacity = 5;

    public void in(Integer i){
        queue.offer(i);
    }

    public void out(){
        queue.poll();
    }

    public boolean isFull(){
        return queue.size() == 5;
    }

    public boolean isEmpty(){
        return queue.size() == 0;
    }

    public Integer count(){
        return queue.size();
    }
}

/**
 * 生产者消费者模型实现主要考察线程安全问题和通信问题，wait与notify的使用是重点
 * wait与notify一定要在同一个监视器下进行通信，通知时必须使用监视器对象进行通知
 * 使用其他的对象进行调用wait和notify会进入其他监视器内部进行通信所以会有问题。
 * 简单说就是使用哪个对象做监视器锁就要用该对象调用wait与notify。
 */
public class Main {
    public static void main(String[] args){
        Repostory repostory = new Repostory();
        Thread t1 = new Thread(new Producer(repostory));
        Thread t2 = new Thread(new Customer(repostory));
        t1.start();
        t2.start();
    }
}
//生产者
class Producer implements Runnable{
    private Repostory repostory;

    public Producer(Repostory repostory){
        this.repostory = repostory;
    }

    @Override
    public void run() {
        while(true){
            synchronized (repostory) {
                if (repostory.isFull()) {
                    try {
                        System.out.println("仓库满了，生产者已等待");
                        repostory.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                repostory.in(1);
                System.out.println("生产者已生产一个:" + repostory.count());
                repostory.notifyAll();
            }
        }
    }
}
//消费者
class Customer implements Runnable{
    private Repostory repostory;

    public Customer(Repostory repostory){
        this.repostory = repostory;
    }

    @Override
    public void run() {
        while(true){
            synchronized (repostory) {
                if(repostory.isEmpty()){
                    try {
                        System.out.println("仓库空了，消费者已等待");
                        repostory.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                repostory.out();
                System.out.println("消费者已消费一个:"+repostory.count());
                repostory.notifyAll();
            }
        }
    }
}
```

# 八、并发工具类

## 1. ThreadLocal

并发安全问题的主要原因就是使用了共享资源，如果多线程之间没有共享资源的话就不存在安全性问题，ThreadLocal就是为我们每个线程绑定一个本地变量来独享数据，以此来解决安全性问题。

### 1.1 基本使用

常用API有三个：get(),set(),remove()，下面是使用示例：

```java
public class Test {
    public static ThreadLocal<Integer> local = new InheritableThreadLocal<Integer>(){
        @Override
        protected Integer initialValue() {
            return 0;
        }
    };

    public static Integer getNext(){
        Integer i = local.get();
        local.set(++i);
        return local.get();
    }

    public static void main(String[] args){
        Thread t1 = new Thread(() -> {
            while(true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程1:"+Test.getNext());
            }

        });
        Thread t2 = new Thread(()->{
            while(true){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程2:"+Test.getNext());
            }
        });
        t1.start();t2.start();
    }
}
```

在jdk1.8新增方法initialValue()初始化值使用，以下实例：

```java
public class Test {
	private static ThreadLocal<Integer> uid = new ThreadLocal() {
		@Override
		protected Object initialValue() {		
			return 10;
		}		
	};
    public static void main(String[] args) {
    	System.out.println(uid.get());
    }
}
```



### 1.2 实现原理

每个线程都绑定了一个map，这个map的key就是使用的ThreadLocal的实例，每次获取都是使用ThreadLocal实例做key到线程的本地map中取值，修改和删除操作也是同样的原理。

下面是源码：

```java
public T get() {
        Thread t = Thread.currentThread();
    	//获取当前线程的本地map
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            //已当前ThreadLocal实例做key查询线程绑定的值返回
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        //如果线程还没有创建本地map则实例化一个，并把ThreadLocal的初始化方法设置为map中的初始化值
        return setInitialValue();
  }

 public void set(T value) {
        Thread t = Thread.currentThread();
        //获取线程本地map
        ThreadLocalMap map = getMap(t);
        if (map != null)
            //向线程绑定的map中设置值
            map.set(this, value);
        else
            createMap(t, value);
 }
```

### 1.3 ThreadLocalMap弱引用key

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

> 这里把key(ThreadLocal)设置为弱引用，目的是当线程外的ThreadLocal=null时，每个线程中key副本就会在下次GC时被回收。原因是ThreadLocal都已经不被外界引用了它所对应entity肯定也没有必要存在。
>
> 这样带来的问题是会造成内存泄露，因为entity的key被回收了但value的强引用还存在当前线程的ThreadLocalMap中，只有等到线程销毁了它才会被回收，如果使用的是线程池的话线程不会被销毁所以会造成内存泄露。正确的用法是当ThreadLocal不用时用remove删除元素。

## 2.CountDownLatch

### 2.1 基本使用

CountDownLatch主要用来完成线程等待阻塞用的，比如想让某线程在其他两个线程执行完成后再继续执行时，可以使用它来解决。常用API就两个，countDown()减少计数器的值，await()在计数器没有达到0时阻塞线程。在实例化这个类是可以指定计数器的值。下面是使用示例：

```java
public class Test {
   public static void main(String[] args) throws InterruptedException {
       CountDownLatch a = new CountDownLatch(2);
       Thread t1 = new Thread(() -> {
           try {
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           a.countDown();
       });
       Thread t2 = new Thread(() -> {
           try {
               Thread.sleep(3000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           a.countDown();
       });
       t1.start();t2.start();
       a.await();
       System.out.println("主线程执行");    
   }
}
```

### 2.2 实现原理

#### 2.2.1 实现思路

CountDownLatch是基于AQS实现的，他把AQS中state当成了计数器，把CLH队列当作了等待队列，在调用await()时如果计数器的值不为0则会把当前线程加入到等待队列中，当其他线程执行完调用countDown()时则会把计数器值减1，如果值减完是0的话则会把等待队列中的线程全部唤醒。

#### 2.2.2 源码分析

1.构造方法CountDownLatch(int count); 

```java
//首先在构造方法中实例化了一个同步器Sync,这个Sync实现了AQS 
public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
}
//然后再Sync的构造方法中把指定的count传递给了AQS的state属性
private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;

        Sync(int count) {
            setState(count);
        }
        ....
}
```

2.await()

```java
//1.调用了AQS的acquireSharedInterruptibly()方法，sync中没有实现这个所以调用的是父类的
public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
}
//2.AQS中的该方法调用了子类（Sync）实现的tryAcquireShared()
public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
 }
//3.Sync中方法，判断了计数器是否为0，返回1代表其他的线程已执行完，-1代表还有线程正在执行需要等待
protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
}
//4.这时假如返回的是-1则第2.个代码块中应执行doAcquireSharedInterruptibly(arg);
//5.他把当前线程添加到等待队列并阻塞了当前线程
private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                //获得本节点的前一个节点
                final Node p = node.predecessor();
                //如果前一个节点是头节点证明本节点是下一次需要唤醒的节点(head装的是正执行的线程节点)
                if (p == head) {//尝试查看当前计数器的值
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {//第3步已经提到r>0表示所有线程已执行完，下面就需要唤醒等待的线程
                        //并维护队列，把被唤醒的节点设置为头节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;//唤醒后返回
                    }
                }
                //把当前节点加入队列尾后需要把原先的尾节点状态改为SIGNAL,表示这个节点中的线程执行完后			       //需要唤醒下一个节点
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())//6.当上面修改完成后，休眠当前线程(更加入队列的线程)，这					 里要注意，当这个线程被唤醒时会接着这里来进行执行代码！
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

3.countDown()

```java
//1.跟上面套路一样，执行AQS的 releaseShared()
public void countDown() {
        sync.releaseShared(1);
}
//2.在AQS中有调用了实现类Sync的tryReleaseShared()
public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
}
//3.Sync中方法
 protected boolean tryReleaseShared(int releases) {
            //死循环直到CAS修改成功
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;//把计数器值-1
                //使用CAS尝试修改计数器的值
                if (compareAndSetState(c, nextc))
                    return nextc == 0;//修改成功后如果计数器值为0则返回true,代表可以把等待的线程唤醒
            }
 }
//4.tryReleaseShared()执行后会返回到第2步的代码中，如果返回的true执行doReleaseShared();
//5.doReleaseShared()用来释放等待的线程
private void doReleaseShared() {
  
        for (;;) {
            Node h = head;
            //判断等待队列中是否还有等待的线程，有则执行
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {//如果头节点的下一个节点需要被唤醒，则执行
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);//头节点状态初始化成功后则释放等待队列中的线程，看第6步
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }
//6.唤醒等待队列中的线程，形参node是头节点
private void unparkSuccessor(Node node) {
     	//判断头节点的状态的，这三行可以先略过
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);
	    //获取下一个节点，也就是下一个需要唤醒的线程
        Node s = node.next;
        //如果下一个节点有问题则会从队列尾部向前寻找到离头节点最近的需要唤醒的节点保存给s，此时的s就是需	      要我们唤醒的节点
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
    	//如果需要唤醒的节点不为空则，唤醒这个线程
    	//注意：这里唤醒了该线程后，这个线程会继续接着，让该线程等待的代码下面执行，也就是会接着await()          源码分析中的第6步执行，那里会维护队列，把刚刚唤醒的线程维护成头节点
        if (s != null)
            LockSupport.unpark(s.thread);
    }
//7.当有一个节点被唤醒时，此时队列的头节点为刚被唤醒的节点，这时返回第5步的doReleaseShared()后接下来会继续循环执行这个方法，直到当前队列只有一个头节点时才会结束，也就意味着等待的线程已经全部被唤醒了。
```

## 3.CyclicBarrier

### 3.1 基本使用

他是一个线程计数器，用来等待所有线程执行到同一屏障时(调用await()时)，所有线程才会去继续执行，先到的线程需要等待直到所有线程都到达屏障点时才能向下执行。下面是使用示例：

```java
//当这10个线程都执行完await()时才会继续向下执行，并执行CyclicBarrier构造方法中传递的线程
public class Test {

    private static CyclicBarrier cb = new CyclicBarrier(10,() -> {
        System.out.println("都到了开会吧！");
    });

    public static void main(String[] args) {

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    Random r = new Random();
                    Thread.sleep(r.nextInt(4000));
                    System.out.println(Thread.currentThread().getName()+":已到达");
                    cb.await();
                    System.out.println(Thread.currentThread().getName()+":发言");
                    Thread.sleep(r.nextInt(4000));
                    System.out.println(Thread.currentThread().getName()+":下一代已到达");
                    cb.await();
                    System.out.println(Thread.currentThread().getName()+":再次发言");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }

    }
}
```

### 3.2实现原理

实现原理就是维护了一个count计数器，当调用一次await()时count减1，当减完count为0时则释放等待队列中的线程，如果不为0则等待。因为await()可以使用多次所以有一个迭代的概念，使用Generation内部类来代表迭代的版本，每执行完await()被全部唤醒后会把Generation类更新实例来完成迭代。

1.构造方法

```java
//初始化属性值 
public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties <= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;//这个就是计数器
        this.barrierCommand = barrierAction;
 }
```

2.wait()

```java
//1.调用了dowait()
public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // cannot happen
        }
}
//2.dowait()实现了线程的唤醒与等待
private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;

            if (g.broken)
                throw new BrokenBarrierException();

            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }
		   //调用await()是在这里进行count减1操作
            int index = --count;
            //减完如果为0则执行释放线程，否则等待
            if (index == 0) {  
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();//执行传进来的线程
                    ranAction = true;
                    nextGeneration();//在其中释放线程，并创建Generation新实例
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }

            // loop until tripped, broken, interrupted, or timed out
            for (;;) {
                try {
                    if (!timed)//没定时的话就永久等待
                        trip.await();
                    else if (nanos > 0L)//否则带时限等待
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation && ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        // We're about to finish waiting even if we had not
                        // been interrupted, so this interrupt is deemed to
                        // "belong" to subsequent execution.
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();
			   //如果唤醒后generation实例更新则代表已迭代，返回
                if (g != generation)
                    return index;

                if (timed && nanos <= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }
	//3.nextGeneration()
    private void nextGeneration() {
        // 唤醒所有等待的线程
        trip.signalAll();
        // 创建下一次迭代
        count = parties;
        generation = new Generation();
    }
```

## 4.Semaphore

### 4.1 基本使用

信号量，用来保证一断代码同时能有几个线程来执行，下面是使用示例：

```java
//保证同一时间只能有五个线程来执行 s.acquire();与s.release();中间的代码
public class InnerTest {
    public static void main(String[] args){
        Semaphore s = new Semaphore(5);

        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                while(true){
                    try {
                        s.acquire();
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName());
                    s.release();
                }

            }).start();
        }
    }
}
```

### 4.2 原理实现

也是基于AQS实现的，使用state做计数器，一开始构造方法中初始化的值就是初始化state，当acquire()一次就会把state减1，当减完值为<0时阻塞当前线程，当release()一次state值加1，然后去释放线程。

1.构造方法

```java
//1.实例化一个非公平的同步器 
public Semaphore(int permits) {
        sync = new NonfairSync(permits);
}
//2.调用AQS的直接子类Sync构造器
static final class NonfairSync extends Sync {
        private static final long serialVersionUID = -2694183684443567898L;

        NonfairSync(int permits) {
            super(permits);
        }
}
//3.初始化state
abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 1192457210091910933L;

        Sync(int permits) {
            setState(permits);
        }
}
```

1.acquire()

```java
//1.调用了AQS中的acquireSharedInterruptibly()
public void acquire() throws InterruptedException {
      sync.acquireSharedInterruptibly(1);
}
//2.AQS中,又调用了非公平同步器的tryAcquireShared()
public final void acquireSharedInterruptibly(int arg)
      throws InterruptedException {
      if (Thread.interrupted())
          throw new InterruptedException();
      //如果计数器的值减一后小于0则阻塞该线程
      if (tryAcquireShared(arg) < 0)
          doAcquireSharedInterruptibly(arg);
}
//3.NonfairSync中，调用了Sync的方法
protected int tryAcquireShared(int acquires) {
    return nonfairTryAcquireShared(acquires);
}
//4.Sync中
final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();//获取当前计数器的值
        int remaining = available - acquires;//减1操作
        if (remaining < 0 ||//如果小于0则把值返回，代表该线程需要被加入等待队列中
            compareAndSetState(available, remaining))//如果不小于0则CAS替换
            return remaining;//返回后回到第2步中继续
    }
}
//5.阻塞线程doAcquireSharedInterruptibly()在上面哪些源码中介绍过
```

3.release()

```java
//1.调用了AQS中的releaseShared()
public void release() {
    sync.releaseShared(1);
}
//2.AQS中调用了自己实现的同步器Sync中的tryReleaseShared()
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
//3.Sync中
protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();//获取计数器值
        int next = current + releases;//加1操作
        if (next < current) // overflow
            throw new Error("Maximum permit count exceeded");
        if (compareAndSetState(current, next))//自旋替换计数器值直到成功返回true
            return true;//返回后会回到第2步中继续执行
    }
}
//如果第三步返回true，则调用doReleaseShared()去释放等待的线程。这个在前面也介绍过。
```

## 5.Exchanger

### 5.1 基本使用

用来完成两个线程之间的数据交互，在达到交换点后如果其他线程还没达到则等待，下面示例：

```java
public class InnerTest {
    public static void main(String[] args){
        Exchanger<String> ex = new Exchanger<>();
        
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName()+":开始执行");
                Thread.sleep(2000);
                String res = ex.exchange("ab");
                System.out.println(res);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName()+":开始执行");
                Thread.sleep(2000);
                String result = ex.exchange("cd");
                System.out.println("数据已交换:"+result);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

    }
}

```

# 九、Future

## 1.FutureTask与Callable

Callable是新的线程任务提交方式其中的call()类似于run()，Callable被包装在FutureTask中，而FutureTask是Runnable的实现类所以可以传递给Thread构造方法当参数，当Thread执行start()时最终调用的是Callable的call(),下面是使用示例：

```java
public class InnerTest {
    public static void main(String[] args) throws Exception {
        //这里的lambda表达就是Callable的实现与Runnable一样都是函数式接口
        FutureTask<Integer> f = new FutureTask<Integer>(() -> {
            System.out.println("callable正在执行！");
            Thread.sleep(3000);
            return 10;
        });
        
        Thread t = new Thread(f);
        t.start();
        //get()会阻塞线程直到上面线程执行完拿到结果
        int i = f.get();
        System.out.println("执行完成结果为:"+i);
    }
}
```

自己实现一个`FutureTask`

```java
public class InnerTest {
    public static void main(String[] args) throws Exception {
        MyFuture<String> future = new MyFuture<>(() -> {
            System.out.println("开始任务");
            Thread.sleep(2000);
            System.out.println("任务结束");
            return "结果";
        });
        Thread t = new Thread(future);
        t.start();
        String result = future.get();
        System.out.println("获取到:"+result);
    }

    public static class MyFuture<T> implements Runnable{

        private Queue<Thread> queue = new LinkedList<>();
        private Callable<T> target;
        volatile T t = null;

        public MyFuture(Callable<T> target) {
            this.target = target;
        }

        @Override
        public void run() {
            if(target!=null){
                try {
                    //假设call返回来的永远不为null
                    t = target.call();
                    while(!queue.isEmpty()){
                        LockSupport.unpark(queue.poll());
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        public T get(){
            while(t == null){
                queue.offer(Thread.currentThread());
                LockSupport.park(Thread.currentThread());
            }
            return t;
        }
    }
}
```

Runnable与Callable的区别

* callable 可以返回结果，向外抛异常
* callable的call()只是运行在线程中run()里的一个耗时操作而不是异步执行的，而run()则是线程调用的，一个异步执行的方法。

start()与run()区别

* start()会调用系统开辟一个线程，然后再回调run()，这样才能够异步执行。
* run()单独调用并不会异步执行，还是串行执行的。

## 2.fork/join框架

跟归并排序思路一样，就是把大的任务拆分成多个小任务，让每个线程执行一个，执行后把结果合起来返回

```java
public class InnerTest {
    public static void main(String[] args) throws Exception {
        ForkJoinPool pool = new ForkJoinPool();
        Future<Integer> future = pool.submit(new Task(1,100));
        int result = future.get();
        System.out.println("结果为:"+result);
    }

    public static class Task extends RecursiveTask<Integer>{

        private int start;
        private int end;

        public Task(int start,int end){
            this.start = start;
            this.end = end;
        }

        @Override
        protected Integer compute() {
            if(end-start <= 2){
                int sum = 0;
                for (int i = start; i <= end; i++) {
                    sum+=i;
                }
                return sum;
            }

            Task t1 = new Task(start,(start+end)/2);
            Task t2 = new Task((start+end)/2+1,end);
            t1.fork();
            t2.fork();
            int a = t1.join();
            int b = t2.join();

            return a+b;
        }
    }
}
```

# 十、并发集合

## 1. CopyOnWriteArrayList与CopyOnWriteArraySet

采用的读写分离来保证集合的线程安全性，在写操作时加锁并copy一份数组完成写操作，读操作时不加锁，set的实现是基于`CopyOnWriteArrayList`的，add()使用的是`CopyOnWriteArrayList`的不重复的添加API，保证了set集合中元素不可重复的性质，修改没有提供显示的API采用引用修改的方式。

## 2. ConcurrentLinkedQueue与ConcurrentLinkedDeque

采用单向链表实现的一个队列，采用CAS保证线程安全性，在入队时更改next和tail指针时采用CAS，在出队时在设置元素item与head指针时采用CAS，其他就是正常维护队列的操作。Deque是双端队列。

## 3.ConcurrentHashMap

采用CAS和synchronized来保证线程安全，其他跟hashMap一致。创建新桶时使用CAS，向桶中添加节点时用synchronized使用的是当前桶对象做为锁，也有了锁分段的意思。每个桶一个锁。

## 4.ConcurrentSkipListMap与ConcurrentSkipListSet

采用跳表这种数据结构，使用CAS保证线程安全。set内部使用的map。跳表有序，类似二分查找，进行链表分层跳跃查找。

# 十一、原子操作类

## 1. 基本数据类型

### 1.1 AtomicInteger与AtomicLong、AtomicBoolean

| API                       | 描述     |
| ------------------------- | -------- |
| getAndIncrement()         | i++      |
| incrementAndGet()         | ++i      |
| decrementAndGet()         | --i      |
| getAndDecrement()         | i--      |
| compareAndSet(预期，新值) | 原子操作 |

> 底层使用的都是Unsafe类的compareAndSwap*()以及其他的API，AtomicBoolean没有自增API。

## 2.数组类型

### 2.1 AtomicIntegerArray与AtomicLongArray

API跟基本数据类型相似，唯一区别就是可以根据数组下标进行原子操作。

例如：array.compareAndSet(下标,预期, 新值);

### 2.2 AtomicReferenceArray

引用类型的数组原子操作类，没有自增API 其他与之前类似，注意由于是引用类型所以预期值对象必须相同才可以CAS成功。

## 3.引用类型

### 3.1 AtomicReference 

原子操作引用类型，API与引用数组差不多，需要注意预期值与引用对象是否一致。

### 3.2 AtomicReferenceFieldUpdater

原子操作引用类型中的字段，此类是抽象类，要获取实例需使用静态方法AtomicReferenceFieldUpdater.newUpdater(引用类型的Class,引用类型中字段的Class,字段名称);

可以用set()进行初始化值，其他的API与之前类似，compareAndSet(对象, 字段的预期, 新值)

### 3.3 AtomicMarkableReference

带标记的原子操作引用类，为了解决ABA问题，标记采用boolean类型来表示 是否被修改过。

## 4.字段类型

### 4.1 AtomicIntegerFieldUpdater与AtomicLongFieldUpdater

原子操作Integer/Long类型字段，API还是字段那一套，AtomicIntegerFieldUpdater.newUpdater(tclass, fieldName)获取实例，由于字段类型已知所以泛型不需要字段类型的class。

### 4.2 AtomicStampedReference

带版本号的原子操作引用类，解决ABA问题。

## 5.Atomic分段计数器

atomic类在高并发下性能不是很好太耗费CPU资源，于是就在JDK1.8出现了LongAdder，DobuleAdder类来替代Atomic类，其内部实现类似于分段锁，每个线程都有单独的计数器。使用时的API跟Atomic类一样。

# 十二、阻塞队列

阻塞队列就是当生产者存值时队列已满会进行阻塞线程，当取值后会唤醒阻塞的生产者线程，取值与之类似 BlockingQueue是阻塞队列的根接口，主要实现如下

## 1. ArrayBlockingQueue 

基于数组实现的一个单向阻塞队列，初始化两个等待队列(Condition)，分别为消费者和生产者使用，还初始化一个可重入锁，可以指定公平性。核心API，take()与put()会造成阻塞。这个阻塞队列是有界的，也就是存储元素有限制。先进先出的阻塞队列。

源码分析：构造函数

```java
public ArrayBlockingQueue(int capacity, boolean fair) {
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];//初始化数组
    lock = new ReentrantLock(fair);   //初始化锁
    notEmpty = lock.newCondition();	  //初始化两个等待队列
    notFull =  lock.newCondition();
}
```

take()

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        //队列空了就把当前线程加入到notEmpty等待队列中
        while (count == 0)
            notEmpty.await();
        //取值并返回
        return dequeue();
    } finally {
        lock.unlock();
    }
}
```

dequeue()

```java
private E dequeue() {
    // assert lock.getHoldCount() == 1;
    // assert items[takeIndex] != null;
    final Object[] items = this.items;
    @SuppressWarnings("unchecked")
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    notFull.signal();//取值后唤醒生产者队列
    return x;
}
```

put()

```java
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        //如果队列已满则会阻塞当前线程
        while (count == items.length)
            notFull.await();
        //存值操作
        enqueue(e);
    } finally {
        lock.unlock();
    }
}
```

enqueue()

```java
private void enqueue(E x) {
    // assert lock.getHoldCount() == 1;
    // assert items[putIndex] == null;
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    notEmpty.signal();//存值后唤醒消费者队列
}
```

## 2. LinkedBlockingQueue

底层使用的单向链表，是一个有界的阻塞队列，使用的容量默认是Integer的最大值。其余的take与put原理与ArrayBlockingQueue类似。先进先出的阻塞队列。

## 3. PriorityBlockingQueue

与前两个FIFO的队列不同，这个队列是带优先级的，底层使用二叉堆，使用者需要提供比较器，如不提供则使用自然规则比较优先级进行维护堆结构，默认是最小堆，至于是最大堆还是最小堆需要看提供的比较器是如何比较的。这是一个无界的阻塞队列。

源码分析：构造函数

```java
public PriorityBlockingQueue(int initialCapacity,
                             Comparator<? super E> comparator) {
    //使用时提供初始化数组的长度，与比较器
    if (initialCapacity < 1)
        throw new IllegalArgumentException();
    this.lock = new ReentrantLock();
    //由于是无界队列，所以只有一个消费者等待队列，生产时是不会发生阻塞的
    this.notEmpty = lock.newCondition();
    this.comparator = comparator;
    this.queue = new Object[initialCapacity];
}
```

put()

```java
public void put(E e) {
        offer(e); // never need to block
}

public boolean offer(E e) {
    if (e == null)
        throw new NullPointerException();
    final ReentrantLock lock = this.lock;
    lock.lock();
    int n, cap;
    Object[] array;
    //扩容
    while ((n = size) >= (cap = (array = queue).length))
        tryGrow(array, cap);
    try {
        Comparator<? super E> cmp = comparator;
        //如果使用者没有指定比较器则使用自然规则比较，也就是类继承的Comparable的实现
        if (cmp == null)
            siftUpComparable(n, e, array);
        else
            siftUpUsingComparator(n, e, array, cmp);
        size = n + 1;
        notEmpty.signal();//唤醒消费者
    } finally {
        lock.unlock();
    }
    return true;
}
```

siftUpComparable(),siftUpUsingComparator()

```java
private static <T> void siftUpComparable(int k, T x, Object[] array) {
    //没有提供比较器，就使用元素实现的Comparable
    Comparable<? super T> key = (Comparable<? super T>) x;
    while (k > 0) {
        //(n-1)/2求出父节点
        int parent = (k - 1) >>> 1;
        Object e = array[parent];
        //如果n>=parent不做为，否则维护堆结构
        if (key.compareTo((T) e) >= 0)
            break;
        array[k] = e;
        k = parent;
    }
    array[k] = key;
}
```

```java
private static <T> void siftUpUsingComparator(int k, T x, Object[] array,
                                              Comparator<? super T> cmp) {
    while (k > 0) {
        int parent = (k - 1) >>> 1;
        Object e = array[parent];
        //使用提供的比较器来维护堆
        if (cmp.compare(x, (T) e) >= 0)
            break;
        array[k] = e;
        k = parent;
    }
    array[k] = x;
}
```

take()

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    E result;
    try {//如果队列为空则阻塞
        while ( (result = dequeue()) == null)
            notEmpty.await();
    } finally {
        lock.unlock();
    }
    return result;
}
```

dequeue()

```java
private E dequeue() {
    int n = size - 1;
    if (n < 0)
        return null;
    else {
        Object[] array = queue;
        //取出堆顶元素
        E result = (E) array[0];
        //取出堆中最末尾的元素并替换堆顶维护堆结构
        E x = (E) array[n];
        array[n] = null;
        Comparator<? super E> cmp = comparator;
        if (cmp == null)
            siftDownComparable(0, x, array, n);
        else
            siftDownUsingComparator(0, x, array, n, cmp);
        size = n;
        return result;
    }
}
```

## 4. DelayQueue

是一种延迟阻塞队列，通常用于存储延迟任务，比如淘宝下订单30分钟为付款就会自动取消订单等。他是一个无界阻塞队列，顺序基于延迟时间做优先级，通常剩余延迟时间较少的排在队列前面。其内部使用的存储结构使用的是PriorityQueue作为存储容器，底层也是使用的二叉堆与上面的PriorityBlockingQueue实现差不多。DelayQueue中存储的元素必须实现Delayed接口。

使用示例：

```java
public class Test {

	public static void main(String[] args) throws Exception {
		DelayQueue<DelayTask> bq = new DelayQueue<>();
        //构建两个延迟队列的元素，分别5秒后执行与10秒后执行
		DelayTask task1 = new DelayTask(5000L, ()-> System.out.println("task1"));
		DelayTask task2 = new DelayTask(10000L, ()-> System.out.println("task2"));
		bq.put(task1);
		bq.put(task2);
		//定义一个守护线程，负责执行到期的延迟任务
         Thread deamon = new Thread(()->{
			ExecutorService pool = Executors.newFixedThreadPool(10);
			while(true) {
				try {//到期则会被取出否则进行阻塞(阻塞时间为队列中头元素的剩余延迟时间)
					DelayTask item = bq.take();
					pool.execute(item.task);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		});
		deamon.start();
	}
}
//实现Delayed接口，Delayed接口继承了comparable所以比较器也要实现
class DelayTask implements Delayed {
	private Long time;
	public Runnable task;
	//初始化延迟时间与执行的任务
	public DelayTask(Long time,Runnable task) {
		this.time = System.currentTimeMillis()+time;
		this.task = task;
	} 
	//根据剩余延迟时间比较
	@Override
	public int compareTo(Delayed o) {
		Long result = getDelay(TimeUnit.NANOSECONDS)-o.getDelay(TimeUnit.NANOSECONDS);
		return result<0 ? 1 : 0;
	}
	//获取剩余的延迟时间
	@Override
	public long getDelay(TimeUnit unit) {
		return unit.convert(time - System.currentTimeMillis(), unit.NANOSECONDS);
	}
	
}
```

源码分析：

put()

```java
public void put(E e) {
    offer(e);
}

public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {//把元素存入优先队列中
        q.offer(e);
        //如果刚加入的元素就是堆顶元素代表之前等待的线程(leader)等待时间需要重置，所以唤醒他
        if (q.peek() == e) {
            leader = null;
            available.signal();
        }
        return true;
    } finally {
        lock.unlock();
    }
}
```

take()

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        for (;;) {
            E first = q.peek();
            if (first == null)//队列为空阻塞消费者
                available.await();
            else {//获取剩余延迟时间
                long delay = first.getDelay(NANOSECONDS);
                if (delay <= 0)//小于0代表延迟时间已过可以出队
                    return q.poll();
                first = null; // don't retain ref while waiting
                //到这里说明头元素延迟时间还没到，需要阻塞取元素的线程
                if (leader != null)//leader不为空代表有其他线程正在限时等待获取头元素则本线程进入等待
                    available.await();//队列
                else {//到这里说明还没有其他线程即将等待获取元素，则把本线程设置为leader
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;
                    try {//设置为leader后进入限时等待中，限时等于头元素的剩余延迟时间，当leader醒来后
                        available.awaitNanos(delay);//头元素的延迟时间也已到就可以获取头元素
                    } finally {
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {
        if (leader == null && q.peek() != null)
            available.signal();
        lock.unlock();
    }
}
```

## 5. SynchronousQueue 

SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。

如果以洗盘子的比喻为例，那么这就相当于没有盘架，而是将洗好的盘子直接放入下一个空闲的烘干机中。这种实现队列的方式看似很奇怪，但由于可以直接交付工作，从而降低了将数据从生产者移动到消费者的延迟。（在传统的队列中，在一个工作单元可以交付之前，必须通过串行方式首先完成入列[Enqueue]或者出列[Dequeue]等操作。）

直接交付方式还会将更多关于任务状态的信息反馈给生产者。当交付被接受时，它就知道消费者已经得到了任务，而不是简单地把任务放入一个队列——这种区别就好比将文件直接交给同事，还是将文件放到她的邮箱中并希望她能尽快拿到文件。

因为SynchronousQueue没有存储功能，因此put和take会一直阻塞，直到有另一个线程已经准备好参与到交付过程中。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用同步队列。

使用示例：

```java
public static void main(String[] args) throws Exception {
    SynchronousQueue<Integer> q = new SynchronousQueue<>();
    //一个线程存一个线程取，只有匹配了才不会阻塞
    new Thread(()->{
        try {
            q.put(10);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }).start();
    new Thread(()->{
        try {
            q.take();
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }).start();
}
```

使用场景：Executors.newCachedThreadPool() 中就用到了这个阻塞队列。

> 只有消费者等待时使用offer添加元素才会成功，否则会失败

## 6. LinkedTransferQueue

是一个由链表组成的无界阻塞队列，比较特殊的是有一个预占模式，没有元素了就占着这个位置直到拿到为止。

## 7. LinkedBlockingDeque

由双向链表组成，运行了工作窃取模式。

工作窃取模式：

每个消费者都有一个自己的双端队列。如果一个消费者完成了自己的双端队列中的全部工作，它可以偷取其他双端队列中 末尾 的任务 

# 十三、线程池

## 1.优点

* 节省资源，节省了创建和销毁线程的资源
* 加快响应速度，提前创建好拿来即用
* 方便管理线程数量

## 2. 线程池框架

![](/多线程实践/1539162969.jpg)

其中`ScheduledThreadPoolExecutor`也是`ThreadPoolExecutor`的子类，上图可知Executor是线程池的根接口，而ExecutorService提供了关闭线程池的API。主要实现类有两个，一个是即时执行的线程池一个是定时执行的线程池

线程池的使用可以用Executors工具类来创建，也可以直接new这两个实现类。

## 3.ThreadPoolExecutor使用与原理

### 3.1主要属性

```java
//线程池把ctl分为两部分，高三位部分代表线程状态，第29位代表线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//二进制的高三位偏移量 值为29
private static final int COUNT_BITS = Integer.SIZE - 3;
//线程容量
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

//简洁计算方式：这些10进制值转化为二进制的结果(只保留低三位)就是高三位的占位表示，高三位表示如下
private static final int RUNNING    = -1 << COUNT_BITS; //111
private static final int SHUTDOWN   =  0 << COUNT_BITS; //000
private static final int STOP       =  1 << COUNT_BITS; //001
private static final int TIDYING    =  2 << COUNT_BITS; //010
private static final int TERMINATED =  3 << COUNT_BITS; //011

//获取当前线程状态(高三位的值)
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取线程数量(低29位的值)
private static int workerCountOf(int c)  { return c & CAPACITY; }
//把高位与低位融合成ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }

//任务队列，由构造函数提供实例
private final BlockingQueue<Runnable> workQueue;
//线程工厂，用来创建线程的
private volatile ThreadFactory threadFactory;
//拒绝策略，当任务队列与线程都满时则使用此拒绝策略
private volatile RejectedExecutionHandler handler;
//线程空闲存活时间
private volatile long keepAliveTime;
//允许核心线程超时，默认为false
private volatile boolean allowCoreThreadTimeOut;
//核心线程数量
private volatile int corePoolSize;
//最大线程数量
private volatile int maximumPoolSize;
//默认拒绝策略
private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();
```

### 3.2线程池的状态

1. **RUNNING** ：该状态的线程池会接收新任务，并处理阻塞队列中的任务； 
2. **SHUTDOWN** ：该状态的线程池不接收新任务，但会处理阻塞队列中的任务；
3. **STOP**  ：该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务； 
4. **TIDYING**  ：该状态表示线程池对线程进行整理优化； 
5. **TERMINATED** ：该状态表示线程池停止工作； 

### 3.3拒绝策略

1. **ThreadPoolExecutor.AbortPolicy**：丢弃任务并抛出RejectedExecutionException异常.
2. **ThreadPoolExecutor.DiscardPolicy**：也是丢弃任务，但是不抛出异常。
3. **ThreadPoolExecutor.DiscardOldestPolicy**：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 
4. **hreadPoolExecutor.CallerRunsPolicy**：由调用线程处理该任务。 

> 除此之外自己也可以实现RejectedExecutionHandler接口，自定义拒绝策略，比如持久化任务或记录日志

### 3.4使用实例

```java
	public static void main(String[] args) {
        //创建一个线程池，核心线程数为5，最大线程数10，空闲时间5分钟，提供一个阻塞队列存储任务
		ExecutorService pool = new ThreadPoolExecutor(5, 10, 
				5, TimeUnit.MINUTES, new LinkedBlockingQueue<>(10));
		for(int i =0;i<100;i++) {
             //提交任务
			pool.execute(()-> System.out.println(Thread.currentThread().getName()));
		}
	}
```

### 3.5构造函数

总共有四个构造函数，根据参数不同进行重载，下面列举出构造函数中的所有参数

1. corePoolSize：核心线程数
2. maximumPoolSize：最大线程数
3. keepAliveTime：最大空闲时间
4. TimeUnit unit：时间单位
5. BlockingQueue<Runnable> workQueue：任务队列 
6. threadFactory：创建线程的工厂，如果没指定则使用Executors中的默认工厂
7. RejectedExecutionHandler handler：拒绝策略                     

```java
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

### 3.6提交任务

1.有两种提交任务的方式，分别是execute()和submit()，execute()是根接口Executor定义的没有返回值，submit()是ExecutorService定义的可以返回线程计算结果。

2.execute()

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    //如果当前线程数<核心线程数，则创建新的线程执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }//到这里说明当前线程数>核心线程数，则把任务添加到任务队列中
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }//到这里说明没有空闲的核心线程并且任务队列也满了，则会尝试创建非核心线程执行任务
    else if (!addWorker(command, false))
        reject(command);//如果新建线程失败则会调用拒绝策略
}
```

3.addWorker()

```java
//参数core为true表示创建的是核心线程，false表示创建的非核心线程
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);//获取线程状态

        // 如果当前状态>=SHUTDOWN则拒绝添加新的任务
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;
	    //使用CAS自旋把池子中线程数+1，ctl+1
        for (;;) {
            int wc = workerCountOf(c);//获取池子中的线程数
            //检测线程数量是否溢出，如果溢出则返回fasle创建工作线程失败
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            //使用CAS对池子中线程数+1，成功后停止自旋
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }
    //到这里说明池子中的线程数已+1，则需要创建工作线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {//创建Worker实例，这个实例初始化时会新建工作线程
        w = new Worker(firstTask);
        final Thread t = w.thread;//获取新建的线程
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();//执行新建的线程
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

Worker类

```java
    private final class Worker
        extends AbstractQueuedSynchronizer//利用AQS的state来表示当前线程是否空闲，如果空闲则shutdown()可以中断该类中封装的线程
        implements Runnable//实现了runnable，封装了用户提交的任务
```

Worker类构造函数

```java
Worker(Runnable firstTask) {
    setState(-1); // 禁止中断直到执行了runWorker()
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);//创建工作线程
}
```

Worker类run()

```java
public void run() {
    runWorker(this);
}
```

Worker类runWorker()，这个方式是线程池中的线程执行的，它会一直从任务队列中获取任务执行

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 允许shutdown()中断线程
    boolean completedAbruptly = true;
    try {//执行提交的任务，并循环从任务队列中获取任务，如果任务队列中没有任务将会阻塞线程
        while (task != null || (task = getTask()) != null) {
            w.lock();//加锁的这段代码在执行中时shutdown()是不会中断该线程的
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();//执行任务
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        //线程释放前清理资源
        processWorkerExit(w, completedAbruptly);
    }
}
```

Worker类getTask()，从工作队列中获取任务

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 如果线程池状态为SHUTDOWN并且队列中没有任务了则会返回null，导致线程退出。
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        //当前线程是否受空闲时间限制,true为受限制
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
	    
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            //到这里说明线程已超时则把池子中的线程数-1，并结束该方法的执行，也就结束了该线程的生命，
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {//如果受空闲时间限制则使用带时限的poll()获取任务，当空闲时间过去后还未获取到任务将不会阻塞
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            workQueue.take();//如果不受空闲时间限制则一直阻塞下去，直到新任务的到来。
            if (r != null)
                return r;
            timedOut = true;//到这里说明此线程空闲时间已超时
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

第二种提交任务的方式submit()

```java
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    //把Runnable转换成了callable，并封装入FutureTask中由execute()执行任务
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
```

### 3.7关闭线程池

关闭线程池有两个方法，shutdown()不会中断工作中的线程，shutdownNow()会中断工作中的线程

shutdown()

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);//更改线程池状态为SHUTDOWN
        interruptIdleWorkers();//中断空闲的线程
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
```

interruptIdleWorkers()

```java
private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {//遍历线程池中的线程
        for (Worker w : workers) {
            Thread t = w.thread;
            //如果w.tryLock()为true表示t线程是空闲的可中断，因为线程工作过程中锁肯定是被持有的
            //tryLock()是不会成功的
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt();//中断线程
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

> 上面的代码把空闲的线程中断了，那非空闲的线程怎么完成关闭的呢？这就要看getTask()，由于shutdown()中把线程状态改为了shutdown，所以导致getTask()返回为null，因此导致线程退出。
>

shutdownNow()

```java
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        interruptWorkers();//执行中断线程
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

interruptWorkers()

```java
private void interruptWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {//遍历线程进行中断
        for (Worker w : workers)
            w.interruptIfStarted();
    } finally {
        mainLock.unlock();
    }
}
```

interruptIfStarted()

```java
void interruptIfStarted() {
    Thread t;
    //state>=0代表不管是空闲的还是非空闲的线程都中断掉
    if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
        try {
            t.interrupt();
        } catch (SecurityException ignore) {
        }
    }
}
```

## 4.线程池优化

### 4.1 提前创建核心线程

默认情况下线程池只有任务提交过来后才会创建核心线程属于懒加载，我们可以使用prestartAllCoreThreads()或prestartCoreThread()提前把核心线程创建来提高响应速度。

### 4.2 定制线程工厂

创建线程池时如果没有指定线程工厂，将会使用Executors提供的默认工厂创建线程，这样的话所有的线程都在同一个组中，拥有同样的优先级，我们可以自定义一个工厂来配置线程创建的参数，比如给线程起名字。

### 4.3 核心线程回收

默认情况下只有非核心线程超过最大空闲时间后才会被回收，我们可以使用allowCoreThreadTimeOut(true)来配置。

### 4.4 正确的选择阻塞队列

根据场景选择使用一下三种队列，有界、无界、直接提交。

## 5.Executors

```java
Executors.newCachedThreadPool();	//使用SynchronousQueue做缓存线程池，有空闲线程则复用空闲线程，没有则新建线程，理论上没有线程上限，不存在任务队列的概念。
Executors.newFixedThreadPool(10);	
Executors.newScheduledThreadPool();
Executors.newSingleThreadExecutor();
Executors.defaultThreadFactory()；
Executors.callable(task);	//把runnable转换为callable
```
# 附录：

## 1. CPU Cache与缓存行

相关知识文章：https://mp.weixin.qq.com/s/4oU6YqxHso2ir0NXtBuaog

基础部分：多线程的使用限制，基础的API使用，synchronized系列的技术（锁优化，锁升级，实现原理），volatile系列技术（实现原理，可见性，重排序）

JMM部分：内存可见性相关，顺序一致性相关，重排序，一些原语的内存语义

juc包部分的：AQS CAS 并发工具 线程池 原子操作相关的 并发集合相关的

## 2. 手写生产者消费者模型

文章：https://mp.weixin.qq.com/s/R1cw5XoP8QeMpIKZOlFGIA

CLH https://blog.csdn.net/luotuomianyang/article/details/52251554

