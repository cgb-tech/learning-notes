# 一、XA(二阶段提交)

原理：故名思意它把事务的提交分为两个阶段，第一个阶段用来询问分布式事务中的多个操作是否都已成功，如果都成功才会进入第二阶段提交事务，如果有一个操作失败则会在第二阶段进行回滚之前成功的操作。一般都在同一个系统对多个数据源进行写操作时使用XA方案，比如向数据库和MQ中同时写一条数据时我们会有两个事务管理器，使用Spring+JTA来实现分布式事务保证数据库和MQ中的数据一致性，他会有一个JTA事务管理器，用来管理多个数据源的事务，在第一阶段时如果多个数据源的事务都成功了，JTA事务管理器才会提交事务，否则所有事务都会回滚。

SpringBoot中使用：

```xml
     <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-jta-atomikos</artifactId>
     </dependency>
```

在需要事务的代码中加@Transactional

# 二、TCC

## 1.原理

TCC(try Confirm Cancel)，TCC把事务执行分为了这三阶段。

try：尝试执行，预执行阶段，在这个阶段并不会真正的去修改业务数据，而是修改一些预处理的字段数据，比如要转库存，则可以把预减少库存值添加入库而不是真正的修改库存。

Confirm：如果try阶段都执行成功了则会执行Confirm阶段进行真正的业务数据处理。

Cancel：如果try阶段执行有执行失败的操作则执行此阶段来回滚之前处理的操作，比如把添加好的库存减回去

在使用TCC的时候需要为原先的每步业务操作分别做这三个阶段的业务处理都要编写对应的业务代码，实现起来比较复杂，需要添加大量的业务逻辑代码。一般在使用TCC时还要引入TCC框架来感知各个服务的业务处理情况，比如try是否成功了还是失败了，然后自动调用我们提供好的Confirm或Cancel的代码。常用的框架有ByteTCC、Hmily、TCC-transaction。

**应用场景**：一般TCC都用于对一致性要求比较高的场景。从用户的角度来说，当用户完成一个操作时需要立刻就能看到结果的场景适合使用TCC。例如买课操作，用户下单并支付完成后需要立刻就能够观看付费后的课程视频，这种对数据一致性的实时性要求比较高的场景。

# 三、本地消息表

## 1.原理

这种方式需要在本地创建一个额外的消息表，消息发送方会在本地把消息数据插入消息表并把消息发送到MQ中，消费方系统接收到消息后执行业务操作，当操作完成时就回去消息表中把对应消息的状态进行修改，生产者会监听发送消息的状态如果长时间状态都没有被消费者改变就会认为消息发送失败会进行重新发送消息，也可以基于zookeeper实现，生产者和消费者都会监听zookeeper的一个对应这条消息的节点状态，当消费者执行业务失败时不会修改节点状态，再生产者那边如果消费者超时没有修改这个消息的节点状态则会认为消息处理失败了进行补偿重发消息。

# 四、最终一致性解决方案

这种方式基于MQ来实现分布式事务，RocketMQ、Kafka都有事务API支持，原理是在生产者发送消息时一开始发送一条半消息，也叫透明消息，这个消息对于消费者来说是不可见的，当生产者的业务都执行成功后会执行消息的事务提交通知给服务端，这时消息才能被真正的推送给消费者，如果业务执行失败了则会回滚这条消息。消费者消费到消息的时候证明生产者一定是执行成功的，只要消费者也执行成功就可以了，如果消费者执行失败则重试直到成功或者重试到一定次数做记录发邮件通知进行手动干预做补偿解决问题。

如果是rabbitmq的话想要实现最终一致性的效果需要特殊的架构设计，如下：

在生产者端，在支付回调中使用MQ来传递添加用户积分的消息，并编写消息确认回调函数，当回调函数被执行但消息为被确认掉的话则进行重试接着把消息发送到MQ中。

在消费者端，提供俩个消费者队列与消费者，其中一个是积分服务消费者、一个是补偿消费者，当补偿消费者接收到添加积分的消息后会查询当前订单的支付状态，如果状态时未支付成功的话则进行补偿，把支付状态变为成功。

**应用场景：**对于数据一致性要求不高的时候可以使用，例如电商网站购物，用户买完一个商品，只需要看到订单完成就可以至于仓储服务是否有立刻执行发货的操作对于用户来说时不可见了用户也不会关心，系统只需要保证最终这个仓库服务能够把货发出去就可以。